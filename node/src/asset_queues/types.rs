use crate::primitives::ParticipantId;
use borsh::{BorshDeserialize, BorshSerialize};
use near_indexer::near_primitives::hash::hash;
use near_indexer_primitives::CryptoHash;
use std::collections::{BTreeMap, HashSet};

/// A random hash generated by each participant, that is only changed when their
/// asset DB is dropped and recreated. Changing the serial number signals to all
/// others that all assets using the previous serial number for this participant
/// shall be dropped.
pub type SerialNumber = CryptoHash;

/// A unique identifier for a specific asset queue; this is the hash of the
/// [`ParticipantsWithSerials`] struct.
pub type AssetQueueKey = CryptoHash;

#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize, Default)]
pub struct ParticipantsWithSerials {
    pub participants: BTreeMap<ParticipantId, SerialNumber>,
}

/// Describes what should be done for the assets in a particular queue.
pub(crate) enum QueueUsability {
    /// The assets in the queue can be used right now because all participants are online and with
    /// matching serial numbers.
    Online,
    /// The assets in the queue cannot be used right now because some participants are offline,
    /// though the online ones have matching serial numbers, so these assets may be usable once the
    /// offline participants come back online.
    Offline,
    /// The assets in the queue are never usable again due to any of the following:
    ///  - At least one of queue's participants is no longer a current participant in the network.
    ///  - The number of participants used for this queue is lower than the current signature
    ///    threshold.
    ///  - The serial number of at least one of the queue's participants no longer matches the
    ///    current serial number reported by the participant.
    NoLongerUsable,
}

impl ParticipantsWithSerials {
    pub fn key(&self) -> AssetQueueKey {
        hash(&borsh::to_vec(self).unwrap())
    }

    pub fn determine_usability(
        &self,
        online_set: &ParticipantsWithSerials,
        all_participants: &HashSet<ParticipantId>,
        threshold: usize,
    ) -> QueueUsability {
        if self.participants.len() < threshold {
            return QueueUsability::NoLongerUsable;
        }
        let mut any_participant_offline = false;
        for (queue_participant, queue_serial) in &self.participants {
            if !all_participants.contains(queue_participant) {
                return QueueUsability::NoLongerUsable;
            }
            if let Some(online_serial) = online_set.participants.get(queue_participant) {
                if queue_serial != online_serial {
                    return QueueUsability::NoLongerUsable;
                }
            } else {
                any_participant_offline = true;
            }
        }
        if any_participant_offline {
            QueueUsability::Offline
        } else {
            QueueUsability::Online
        }
    }
}

/// Given that a queue is not [`QueueUsability::Corrupted`], this enum describes its state for the
/// purpose of helping to decide which queue to generate new assets into, and which queue to
/// consume assets from.
#[derive(Clone, Copy, PartialEq, Eq)]
pub(crate) enum QueueDesirability {
    /// The queue is online and desirable, meaning that we should pick these queues to generate
    /// assets for. These are also picked for consuming assets as long as there are no more
    /// undesirable ones.
    OnlineAndDesirable,
    /// The queue is online but undesirable, meaning that we should not generate any assets into it,
    /// and we should prioritize consuming assets from it.
    OnlineButUndesirable,
    /// The queue is offline, so we can neither generate or consume its assets.
    Offline,
}
